1、以cluster模式的PushConsumer为例：
	启动时，会根据topic先从nameser获取获取topic对应的broker address 以及对应的message queue消息队列集合视图，在rmq中，topic-broker-queueId确定一条唯一的消息队列,然后为每条消息队列创建一个PullRequest实例，该pullRequst是实现consumer端主动向broker拉取消息的关键。
	刚刚说到，consumer客户端会为每一条消息队列创建一个PullRequest,然后放入List<PullRequest>,也即PullRequest集合，然后遍历PullRequest集合，在放入一个由PullMessageService类管理的pullRequestQueue，拉取消息的生产消费队列；PullMessageService类是拉取消息的线程抽象模型，也就是使用同一个MQClientInstance实例的所有队列，都会由该线程主动向broker拉取消息，以后会专门说到MQClientInstance类，现在先不讲。
	PullRequest里面有一个属性nextOffset，表明希望重broker拉取的消息的逻辑位移，broker根据nextOffset,会返回一些列内容，该内容在客户端反序列化以后，构造成PullResult实例，该对象有返回的消息集合以及下一次获取消息的位移nextBeginOffset，然后设置回PullRequest.nextOffset，接着将拉取回来的消息交给ConsumeMessageService消费消息线程抽象类去异步处理获取回来的消息，执行用户的消费逻辑；然后在将PullRequest复用，在次放进PullMessageService类管理的pullRequestQueue，从而达到不停拉取消息的效果。



2、PullRequest第一次创建时nextOffset的设置情况：
	如果是pull模式，则重0开始，即重broker 的最小offset开始消费。
	如果是push模式，如果设置的ConsumeFromWhere是一下几种模式：CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST、CONSUME_FROM_MIN_OFFSET、CONSUME_FROM_MAX_OFFSET、CONSUME_FROM_LAST_OFFSET等模式，则走一下处理：
	先从BrokerController.ConsumerOffsetManager.offsetTable 缓存，根据topic@group 获取最新可消费的logic offset；如果查询异常，或不存在，则返回-1，这时，在通过ConsumeQueue获取max logic offset，如果还查询不到则返回0。这里有可能会有一种情况出现，就是当broker启动时，由于ConsumeQueue是异步重新加载恢复的，这时后可能consumer端会向该broker发起消费请求，但ConsumeQueue还没加载完成，导致返回0，这时，consumer端会可能从头消费一遍该消息队列。



3、Cluster 模式，PushConsumer 拉取消息然后commit消息流程：
	公共流程：
	首先，对批量拉取回来的消息进行反序列化，然后在过滤掉不包含本consumer端所指定tag的消息。
	然后，拉取回来的消息，根据offset，进行排序。接着将详细委托ConsumeMessageService类进行异步消费
	3.1并发消费(ConsumeMessageConcurrentlyService)：
